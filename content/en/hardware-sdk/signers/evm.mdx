---
title: EVM Signer
---

# EVM Signer

End-to-end EVM signing guide (OneKey). Covers address confirmation, EIPâ€‘1559/Legacy transactions, personal_sign, EIPâ€‘712, EIPâ€‘7702 authorization, and Safe address display. All sections are aligned with the hardware-js-sdk behavior (Promise responses + UI events).

## ðŸ”¹ Index

1. [How it works](#-how-it-works)
2. [Installation](#-installation)
3. [Initialization](#-initialization)
4. [Use Cases](#-use-cases)
   - [Get Address](#use-case-1-get-address)
   - [Sign Transaction (1559 / Legacy)](#use-case-2-sign-transaction)
   - [Sign Message (personal_sign)](#use-case-3-sign-message)
   - [Sign Typed Data (EIP-712)](#use-case-4-sign-typed-data)
   - [Sign Delegation Authorization (EIP-7702)](#use-case-5-sign-delegation-authorization-eip-7702)
   - [Display Safe Address](#use-case-6-display-safe-address)
5. [Interaction & Status](#-interaction--status)
6. [Examples](#-examples)
7. [Validation & Troubleshooting](#-validation--troubleshooting)

## ðŸ”¹ How it works

- `HardwareSDK` talks to the OneKey device app; APIs return `Promise<{ success, payload }>`.
- User interaction is driven by `UI_REQUEST` events (PIN, passphrase, confirm address/tx/message/typed data/app open).
- The device shows path/account, recipient, amount, chainId, fee summary; long `data` is often summarized as a hash.
- Host serializes and verifies with `ethers`/`viem`, then broadcasts via RPC.

## ðŸ”¹ Installation

```bash
npm i @onekeyfe/hd-core @onekeyfe/hd-common-connect-sdk
```

## ðŸ”¹ Initialization

- Keep firmware up to date; Web requires HTTPS + user gestures; BLE needs proper permission.

```ts
import HardwareSDK from '@onekeyfe/hd-common-connect-sdk';
await HardwareSDK.init({ env: 'webusb', fetchConfig: true, debug: false });
const [{ connectId }] = await HardwareSDK.searchDevices();
const deviceId = (await HardwareSDK.getFeatures(connectId)).payload?.device_id;
```

## ðŸ”¹ Use Cases

### Use Case 1: Get Address

```ts
const res = await HardwareSDK.evmGetAddress(connectId, deviceId, {
  path: "m/44'/60'/0'/0/0",
  showOnOneKey: true,
  chainId: 1,
});
// res.payload.address, publicKey?, chainCode?
```

**Parameters**

- `path` (string | number[]): required; BIP44 path.
- `showOnOneKey?` (boolean): optional; display and confirm on device.
- `chainId?` (number): optional; chainId shown on device.

**Returns**

`Promise<{ success, payload: { address, path, publicKey?, chainCode? } }>`

---

### Use Case 2: Sign Transaction

Supports EIPâ€‘1559 (`type: 2`) and Legacy.

```ts
const { success, payload } = await HardwareSDK.evmSignTransaction(connectId, deviceId, {
  path: "m/44'/60'/0'/0/0",
  transaction: tx,
  chainId: 1,
  keepSession: true,
  domain: 'ens.example', // optional
});
// payload: { v, r, s }
```

**Parameters**

- `path`: required.
- `transaction`: required.
  - 1559: `to` `value` `data` `nonce` `gasLimit` `maxFeePerGas` `maxPriorityFeePerGas` `chainId` `type: 2`
  - Legacy: `to` `value` `data` `nonce` `gasLimit` `gasPrice` `chainId`
- `chainId`: required.
- `keepSession?`: optional; reuse session for multiple calls.
- `domain?`: optional; domain label (e.g., ENS) for device display.

**Returns**

`Promise<{ success, payload: { v, r, s } }>`

---

### Use Case 3: Sign Message (personal_sign)

```ts
const res = await HardwareSDK.evmSignMessage(connectId, deviceId, {
  path: "m/44'/60'/0'/0/0",
  messageHex,
  chainId: 1,
});
// res.payload.signature
```

**Parameters**

- `path`: required.
- `messageHex`: required; message to hex (with/without `0x`).
- `chainId?`: optional; shown on device.

**Returns**

`Promise<{ success, payload: { signature } }>`

---

### Use Case 4: Sign Typed Data (EIP-712)

```ts
const res = await HardwareSDK.evmSignTypedData(connectId, deviceId, {
  path: "m/44'/60'/0'/0/0",
  data: typedData,
  chainId: 1,
});
// res.payload.signature
```

**Parameters**

- `path`: required.
- `data`: required; EIPâ€‘712 JSON v4 with `domain/types/primaryType/message`.
- `chainId`: required.

TypedData shape:

```ts
interface TypedData {
  domain: {
    name?: string;
    version?: string;
    chainId?: number;
    verifyingContract?: string;
    salt?: string;
  };
  types: Record<string, Array<{ name: string; type: string }>>;
  primaryType: string;
  message: Record<string, unknown>;
}
```

**Returns**

`Promise<{ success, payload: { signature } }>`

---

### Use Case 5: Sign Delegation Authorization (EIP-7702)

```ts
const res = await HardwareSDK.evmSignDelegationAuthorization(connectId, deviceId, {
  path: "m/44'/60'/0'/0/0",
  chainId: 1,
  contractAddress: '0x...',
  nonce: 0,
});
// res.payload.signature
```

**Parameters**

- `path`: required.
- `chainId`: required.
- `contractAddress`: required; authorized contract.
- `nonce`: required; authorization nonce.

**Returns**

`Promise<{ success, payload: { signature } }>`

---

### Use Case 6: Display Safe Address

Display and verify a Safe contract address on device.

```ts
const res = await HardwareSDK.evmVerifySafeAddress(connectId, deviceId, {
  safeContractAddress: '0x...',
  chainId: 1,
  skipWebDevicePrompt: false,
});
// res.success indicates confirmation
```

**Parameters**

- `safeContractAddress`: required.
- `chainId?`: optional; shown on device.
- `skipWebDevicePrompt?`: optional; skip browser prompt in WebUSB.

**Returns**

`Promise<{ success: boolean }>`

## ðŸ”¹ Interaction & Status

- APIs resolve when the operation finishes; user prompts are surfaced via `UI_REQUEST` events.
- Common prompts: unlock device, open EVM app, verify address, sign transaction, sign personal message, sign typed data.
- For repeated calls, use `keepSession` to reduce PIN/passphrase prompts; run calls serially per device.

## ðŸ”¹ Examples

### EIP-1559 transaction

## Example: EIP-1559 transaction

```ts
import HardwareSDK, { UI_REQUEST, UI_RESPONSE } from '@onekeyfe/hd-core';
import { serialize, TransactionTypes } from '@ethersproject/transactions';

await HardwareSDK.init({ env: 'webusb', debug: false });

const [{ connectId }] = await HardwareSDK.searchDevices();
const deviceId = (await HardwareSDK.getFeatures(connectId)).payload?.device_id;

HardwareSDK.on(UI_REQUEST.REQUEST_PIN, () => {
  // Prompt PIN (prefer on-device); then call uiResponse if needed
});

const accountPath = "m/44'/60'/0'/0/0";
await HardwareSDK.evmGetAddress(connectId, deviceId, { path: accountPath, showOnOneKey: true });

const tx = {
  to: '0xd0d6d6c5fe4a677d343cc433536bb717bae167dd',
  value: '0x0',
  data: '0x',
  nonce: '0x0',
  gasLimit: '0x5208',
  maxFeePerGas: '0x3b9aca00',
  maxPriorityFeePerGas: '0x59682f00',
  chainId: 1,
};

const { success, payload: sig } = await HardwareSDK.evmSignTransaction(connectId, deviceId, {
  path: accountPath,
  transaction: tx,
  chainId: 1,
  keepSession: true,
});

const rawTx = serialize({ ...tx, type: TransactionTypes.eip1559 }, {
  r: sig.r,
  s: sig.s,
  v: Number(sig.v),
});

// Broadcast with your RPC provider, e.g. ethers.js provider.sendTransaction(rawTx)
```

### Legacy transaction (gasPrice)

```ts
const legacyTx = {
  to: '0xRecipient',
  value: '0x2386f26fc10000', // 0.01 ETH
  data: '0x',
  nonce: '0x1',
  gasLimit: '0x5208',
  gasPrice: '0x3b9aca00', // 1 gwei
  chainId: 1,
};

const sig = await HardwareSDK.evmSignTransaction(connectId, deviceId, {
  path: accountPath,
  transaction: legacyTx,
  chainId: 1,
});
```

### Message (personal_sign / EIP-191)

```ts
const message = 'Hello OneKey';
const messageHex = Buffer.from(message).toString('hex');

const res = await HardwareSDK.evmSignMessage(connectId, deviceId, {
  path: accountPath,
  messageHex,
  chainId: 1,
});
// res.payload.signature -> verify with ethers.verifyMessage(message, signature)
```

### Typed data (EIP-712)

```ts
const typedData = {
  types: {
    EIP712Domain: [
      { name: 'name', type: 'string' },
      { name: 'version', type: 'string' },
      { name: 'chainId', type: 'uint256' },
      { name: 'verifyingContract', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
  },
  primaryType: 'Mail',
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  message: {
    from: { name: 'Cow', wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826' },
    to: { name: 'Bob', wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB' },
    contents: 'Hello, Bob!',
  },
};

const res = await HardwareSDK.evmSignTypedData(connectId, deviceId, {
  path: accountPath,
  data: typedData,
  chainId: 1,
});
// res.payload.signature -> recover with ethers.verifyTypedData(domain, types, message, signature)
```

## ðŸ”¹ Validation & Troubleshooting

- Verify on device: path/account, recipient, amount, chainId, fee summary; ensure they match your UI.
- Gas: 1559 requires `maxFeePerGas + maxPriorityFeePerGas`; Legacy uses `gasPrice` only.
- Message/Typed Data: show clear summaries/hashes in UI to avoid phishing; recover signer with `ethers.verifyMessage` / `ethers.verifyTypedData`.
- 7702: validate recovered address per spec.
- Common issues:
  - Path mismatch: default `m/44'/60'/0'/0/0`, increment account/address as needed; confirm once with `showOnOneKey`.
- ChainId mismatch: must match the target network.
- Large `data` may be rejected; simplify if necessary.
- Repeated passphrase prompts: combine `keepSession` with passphrase state and serialize calls per device.
- User reject/timeout: surface retry/cancel; do not auto-replay.
See chain docs: [evmSignTransaction](/en/hardware-sdk/chains/ethereum-and-evm/evmsigntransaction) Â· [evmSignMessage](/en/hardware-sdk/chains/ethereum-and-evm/evmsignmessage) Â· [evmSignTypedData](/en/hardware-sdk/chains/ethereum-and-evm/evmsigntypeddata).
