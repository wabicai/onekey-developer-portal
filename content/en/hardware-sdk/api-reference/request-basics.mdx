---
title: Request Basics
---

# Request Basics

OneKey hardware calls share the same shape: device identifiers, common parameters, HD paths, and UI/event handling. Start here before diving into chain-specific methods.

## Minimal flow

```
init → search devices → pick connectId → get features for deviceId
    → subscribe to UI/DEVICE/FIRMWARE events → call chain method
    → user confirms on device → signature / data returned
```

```ts
import HardwareSDK, {
  DEVICE_EVENT,
  DEVICE,
  UI_EVENT,
  UI_REQUEST,
  UI_RESPONSE,
} from '@onekeyfe/hd-core';

await HardwareSDK.init({ env: 'webusb', debug: false });

const [{ connectId }] = await HardwareSDK.searchDevices();
const { payload: features } = await HardwareSDK.getFeatures(connectId);
const deviceId = features?.device_id;

HardwareSDK.on(DEVICE_EVENT, message => {
  if (message.type === DEVICE.CONNECT) {
    console.info('Device connected');
  }
});

HardwareSDK.on(UI_REQUEST.REQUEST_PIN, payload => {
  // Collect PIN in your UI or guide the user to enter on device
});

HardwareSDK.uiResponse({
  type: UI_RESPONSE.RECEIVE_PIN,
  payload: '1234', // or passphraseOnDevice = true to force on-device input
});

const path = "m/44'/60'/0'/0/0";
const { success, payload } = await HardwareSDK.evmSignTransaction(connectId, deviceId, {
  path,
  transaction: { to: '0x...', value: '0x0', gasLimit: '0x5208', chainId: 1 },
  keepSession: true,
});
```

## Device identifiers

- `connectId`: from `searchDevices()` (field `connectId`); stable across a connection session.
- `deviceId`: from `getFeatures(connectId)` (`device_id`); changes after wipe/factory reset.

## Common parameters (CommonParams)

Pass them directly in the third argument of a chain method:

- `keepSession?: boolean` keep the session after call to reuse cached state.
- `retryCount?: number` / `pollIntervalTime?: number` / `timeout?: number` configure polling retries.
- `passphraseState?: string` / `useEmptyPassphrase?: boolean` control passphrase wallet vs standard wallet.
- `initSession?: boolean` init session at call start and cache `passphraseState`.
- `deriveCardano?: boolean` pre-derive Cardano seed for the session (defaults to false for non-Cardano calls).
- `detectBootloaderDevice?: boolean` detect bootloader mode early and fail fast.
- `skipWebDevicePrompt?: boolean` skip browser device chooser (advanced flows).

Tips:

- Passphrase wallets: pair `passphraseState` with `keepSession` to avoid repeated prompts; use `useEmptyPassphrase` for standard wallet flows.
- WebUSB: requires HTTPS and explicit user gesture before discovery.

## Paths & account selection (HD Path)

- `path: string | number[]` follows BIP44; ed25519 chains must be fully hardened.
- Typical paths:
  - EVM: `m/44'/60'/0'/0/0`
  - BTC: `m/49'/0'/0'` (account) or `m/49'/0'/0'/0/0` (first address)
  - Solana: `m/44'/501'/0'/0'`
- Number-array form example: `[(44 | 0x80000000) >>> 0, (0 | 0x80000000) >>> 0, 0x80000000, 0, 0]`

## Events & UI handling

- Event groups: `UI_EVENT` (UI requests), `DEVICE_EVENT` (device lifecycle), `FIRMWARE_EVENT` (firmware progress).
- High-level: `HardwareSDK.on(UI_EVENT, (message) => {})` gets `{ event, type, payload }`.
- Direct: `HardwareSDK.on(UI_REQUEST.REQUEST_PIN, payload => {})` receives payload only.
- Respond with `HardwareSDK.uiResponse`, common types:
  - `UI_RESPONSE.RECEIVE_PIN` provide PIN
  - `UI_RESPONSE.RECEIVE_PASSPHRASE` provide passphrase (`passphraseOnDevice` to force on-device input)
  - `UI_RESPONSE.SELECT_DEVICE_IN_BOOTLOADER_FOR_WEB_DEVICE` pick a WebUSB bootloader device

## Errors & retry

- See [Error codes](./error-code).
- Combine `retryCount` and `pollIntervalTime` for retry strategies, or watch `DEVICE.CHANGED` to handle device switching.

## Quick checklist

1. Init → search → get `connectId` / `deviceId`
2. Subscribe to `UI/DEVICE/FIRMWARE` and prepare `uiResponse`
3. Choose HD path and chain params, call the chain method with common params
4. Guide the user to confirm on device and read back the signature/result
